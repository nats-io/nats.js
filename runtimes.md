# Runtimes

The NATS client for JavaScript supports many standard runtimes out of the box:

- Node.js
- Deno
- Browser

The runtime is distributed in two different registries:

- npmjs.com - these are npm bundles that target Node.js and compatible runtimes
- jsr.io - these are esm versions

Note that the names of the bundles are the same in the two registries
`@nats-io/<module>`. The reason for this is that code that is properly will look
the same and be compatible across the runtimes provided no additional user-added
dependencies prevent this.

Let's make a project for your favorite runtime, Note that this example is
intended to create a simple development environment, not to explain NATS
concepts, etc. For that refer to the [README.md](README.md).

## Setting Up a Dev Environment

### Node.js

```bash
mkdir -p nats-dev/node
cd nats-dev/node
npm init esnext -y
# the tsx module allows to run typescript files directly by doing `tsx filename.ts`
npm install @nats-io/transport-node tsx
```

### Bun

```bash
mkdir nats-dev/bun
cd nats-dev/bun
bun init -y
bun add @nats-io/transport-node
```

### Deno

```bash
mkdir nats-dev/deno
cd nats-dev/deno
deno init
deno add jsr:@nats-io/transport-deno
```

## Let's add a simple program that we can run

Added to the `nats-dev/<runtime>/index.ts` you used above.

If using Deno, uncomment the second line, and comment out the first.

```typescript
import { connect, deferred, nuid } from "@nats-io/transport-node";
// import { connect, deferred, nuid } from "@nats-io/transport-deno";

const nc = await connect({ servers: "demo.nats.io" });
console.log(`connected`);

const subj = nuid.next();

nc.subscribe(subj, {
  callback: (err, msg) => {
    console.log(msg.subject, msg.json());
  },
});

let i = 0;
const d = deferred();
const timer = setInterval(() => {
  i++;
  nc.publish(subj, JSON.stringify({ ts: new Date().toISOString(), i }));
  if (i === 10) {
    clearInterval(timer);
    d.resolve();
  }
}, 1000);

await d;
await nc.drain();
```

Save it to `index.ts`

## To run:

```bash
# Nodejs
tsx index.ts

# Bun
bun index.ts

# Deno
deno run -A index.ts
```

You should see some output similar to:

```bash
connected
29CODPRD5FJ0INNDXBAOC2 {
  ts: "2024-11-13T17:59:22.853Z",
  i: 1,
}
29CODPRD5FJ0INNDXBAOC2 {
  ts: "2024-11-13T17:59:23.852Z",
  i: 2,
}
...
```

Congratulations. You have a working project. Now go explore the documentation.

## Web Frameworks

Out of the box, the `@nats-io/nats-core` module provides a W3C WebSocket
transport, that you can use directly from Node.js, Bun, Deno and most
importantly in a Browser.

The setup is similar as you have seen above, with the exception that you have to
import and configure your Web frameworks libraries, which is beyond the scope of
this document.

As samples, take a look at my examples for Next.js and React Native pointed to
below. The base projects are generated by the stand tools adding a few
components but showcase connection management, simple pub/sub, kv and object
store monitoring.

Note that only latest versions of the frameworks are known to be compatible, and
while I know that the samples work, but they may not if you have more complex
setups (JavaScript ecosystem is an interesting world.).

### Next.js

Is supported out of the box - if you want to
[see an example, checkout this repo](https://github.com/aricart/nats-nextjs-example)

### React Native

Previous versions of the libraries were difficult to use in React Native
requiring shims and many workarounds to get going. Well, we happy to say that it
works out of the box in the latest version of ReactNative:

```bash
# Run the template generator
npx create-expo-app@latest
# React native is now starting to support package exports
# https://reactnative.dev/blog/2023/06/21/package-exports-support#enabling-package-exports-beta
# set 'resolver.unstable_enablePackageExports = true'

npx expo customize metro.config.js
```

Edit `metro.config.js`:

```js
// Learn more https://docs.expo.io/guides/customizing-metro
const { getDefaultConfig } = require("expo/metro-config");

/** @type {import('expo/metro-config').MetroConfig} */
const config = getDefaultConfig(__dirname);
config.resolver = config.resolver || {};
config.resolver.unstable_enablePackageExports = true;

module.exports = config;
```

That is it - now you can just import `@nats-io/nats-core` and use the WebSocket
client right out of the box. JetStream, KV and ObjectStore all work as well. For
a starting point sample
[take a look at this repo](https://github.com/aricart/nats-react-native)
